# 🚀 [DB 스터디] 쿼리 성능 & 서브쿼리 핵심 요약

## 1. 인덱스(Index): DB의 '목차'

> 데이터 빨리 찾기 위함


### 💡 핵심 원리 (B-Tree)

- **비유:** 책 뒤의 '색인'이랑 똑같음. 색인 없으면 찾을 때까지 책 다 넘겨야 함(Full Scan). 있으면 바로 펼칠 수 있음.

- **구조:** 보통 **B-Tree** 씀. 데이터가 늘 **정렬**되어 있어서 탐색이 빠름.

[B-Tree index structure 이미지](https://encrypted-tbn2.gstatic.com/licensed-image?q=tbn:ANd9GcS3PPjwJaQ2b_ueZ2qoMVX49YcHJmpiJeZausB22whCLb-jXUpvmoY8ArWISjEoMzWRQfqic4MRJEfbQeysm1-Dk4SMzCPcrgmSJ5kMmerPgSE-L1Q)

### ✅ 장단점 (Trade-off)

- **장점:** `SELECT` 속도 상승

- **단점:** `INSERT`, `UPDATE`, `DELETE` 할 때마다 정렬 다시 해야 돼서 **느려짐**. 용량도 차지함.

- **결론:** 무조건 많이 만든다고 좋은 거 아님. (읽기/쓰기 비율 따져야 함)

---

## 2. EXPLAIN: 쿼리 건강검진표

> 쿼리 느리면 무조건 **실행계획(EXPLAIN)** 확인 필요

> 

### 🔍 딱 3개만 보면 됨 (MySQL 기준)

1. **type:** 데이터 어떻게 찾았냐?

    - `ALL`: **풀스캔(위험)**. 테이블 첨부터 끝까지 다 읽음.

    - `ref` / `range`: **인덱스 스캔(굿)**. 인덱스 잘 활용함.

2. **key:** 실제 사용한 인덱스 이름 (`NULL`이면 인덱스 안 쓴 거).

3. **rows:** 훑어본 데이터 개수 (적을수록 좋음).

---

## 3. 풀스캔 vs 인덱스 스캔

> "인덱스는 무조건 빠르다?" 👉 **아님.**

> 

- **인덱스 스캔:** 데이터 조금(10~20% 미만)만 콕 집어 올 때 씀.

- **풀스캔:** 데이터 왕창 가져올 때는 그냥 책 처음부터 읽는 게 빠름. (인덱스 왔다 갔다 하는 게 더 일임)

### ⚠️ 인덱스 못 타는 실수 (이것만 피해도 반은 감)

- `WHERE name LIKE '%김'` (와일드카드 `%`가 앞에 있음)

- `WHERE 함수(컬럼) = 10` (컬럼을 가공해버림)

- 문자열 컬럼인데 숫자로 조회함 (형변환 일어남)

---

## 4. 서브쿼리: IN vs EXISTS

> 상황에 맞춰 써야 성능 저하가 발생하지 않음

> 

### 🆚 한방 정리

| **구분** | **IN** | **EXISTS** |
| --- | --- | --- |
| **방식** | 리스트 다 만들어놓고 "여기 있어?" 확인 | 메인 데이터 보면서 "저기 있어?" 확인 |
| **언제 씀?** | **서브쿼리 결과가 적을 때** | **메인 쿼리 결과가 적고**, 서브쿼리 테이블 클 때 |
| **특징** | 리스트 전체 확인하려는 성향 있음 | 조건 맞는 거 하나 찾으면 **바로 멈춤** (빠름) |

### 📝 코드 예시

### SQL

```sql
-- [IN] 부서 리스트(서브쿼리) 먼저 쫙 뽑고 직원 조회
SELECT * FROM employees WHERE dept_id IN (SELECT id FROM departments ...);

-- [EXISTS] 직원 한 명씩 잡고, 해당 부서 있는지 확인 (있으면 통과, 없으면 다음)
SELECT * FROM employees e WHERE EXISTS (SELECT 1 FROM departments d WHERE ...);
```


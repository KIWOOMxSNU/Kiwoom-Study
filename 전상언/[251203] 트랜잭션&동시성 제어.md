# **1️⃣ 트랜잭션(Transaction)과 ACID 원칙**



## **📌 트랜잭션(Transaction)이란?**

> 데이터베이스에서 수행되는 작업 단위

예: "A → B 계좌로 5만원 송금"

> 

이 작업은 사실 아래처럼 여러 단계로 구성됩니다:

1. A 계좌 잔액 확인

2. A 계좌 잔액 -5만원

3. B 계좌 잔액 +5만원

4. 결과 저장

→ 이 모든 단계를 하나의 묶음(트랜잭션)으로 보아야 데이터가 안전하게 유지됨.

## **📌 ACID 원칙**

트랜잭션이 **안전하게 실행되기 위한 4가지 조건**

### **A. Atomicity (원자성)**

- 트랜잭션은 "모두 성공하거나, 모두 실패해야 한다"

- 중간 단계까지 실행되다 실패하는 일은 없어야 함

➡ 예: 송금 중 오류가 발생하면 A와 B 계좌 모두 **변경 전 상태로 되돌아가야 함**

### **C. Consistency (일관성)**

- 트랜잭션 실행 전/후 데이터의 규칙(제약조건)이 항상 유지되어야 함

    
    예: 전체 계좌 잔액 합은 변하지 않아야 한다

    

### **I. Isolation (격리성)**

- 동시에 여러 트랜잭션이 수행되어도 서로 간섭하면 안 됨

    
    예: A가 잔액 수정 중인데, B가 그 값을 읽으면 안 됨

    

### **D. Durability (지속성)**

- 트랜잭션이 성공하면 결과가 DB에 **영구적으로 저장**되어야 한다

    
    → 서버 재부팅/장애가 발생해도 데이터는 유지됨

    

# **2️⃣ COMMIT / ROLLBACK**

트랜잭션을 마무리하는 두 가지 명령어

## **✔️ COMMIT**

> "지금까지 한 작업을 확정해라"

> 

- DB에 **영구 저장**

- 되돌릴 수 없음

---

## **✔️ ROLLBACK**

> "지금까지 한 작업을 모두 취소해라"

> 

- 트랜잭션 시작 시점으로 되돌림

- 실수했을 때 유용함

---

## **예시 (SQL)**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 50000 WHERE id = 1;
UPDATE accounts SET balance = balance + 50000 WHERE id = 2;
COMMIT;   -- 저장
```

혹은,

```sql
ROLLBACK; -- 모든 변경 취소
```

---

# **3️⃣ 격리 수준(Isolation Level)**

동시에 여러 요청이 들어올 때 "얼마나 서로 간섭을 막을 것인가"를 결정하는 설정.

- 격리 수준이 높을수록 안전하지만 **성능 저하**

- 반대로 낮을수록 빠르지만 **데이터 충돌 위험 증가**

---

## **✔️ 1) READ COMMITTED**

- "커밋된 데이터만 읽을 수 있음"

- 대부분의 DB 기본값

📌 발생할 수 있는 문제: **Non-repeatable Read**

(같은 쿼리를 두 번 실행했는데 값이 달라짐)

---

## **✔️ 2) REPEATABLE READ**

- 트랜잭션 동안 **같은 쿼리는 항상 같은 결과**가 보임

- 더 강력한 고립성

📌 발생할 수 있는 문제: **Phantom Read**

(두 번째 조회에서 새로운 행이 나타나는 문제)

---

## **✔️ 3) SERIALIZABLE**

- 완전한 순차 실행처럼 보이도록 보장

- 동시성이 크게 떨어짐 (성능 ↓)

📌 문제는 가장 적지만 비용이 큼

→ 금융, 재고관리 등 "절대 오차가 나면 안 되는 곳"에서 사용

---

### **🔎 정리: 격리수준 비교표**

| **Isolation Level** | **Non-repeatable Read** | **Phantom Read** | **성능** |
| --- | --- | --- | --- |
| Read Committed | 발생 가능 | 발생 가능 | 빠름 |
| Repeatable Read | 방지됨 | 발생 가능 | 보통 |
| Serializable | 완전히 방지 | 완전히 방지 | 느림 |

---

# **4️⃣ Deadlock(교착상태)**

## **❗ Deadlock이란?**

> 서로 자원을 기다리면서 **무한 대기**

> 

예시:

- 트랜잭션 A가 **행 1**을 잠금

- 트랜잭션 B가 **행 2**를 잠금

- 그리고 A는 **행 2**를 필요

- B는 **행 1**을 필요

→ 서로 상대가 잠근 자원을 기다리며 **대기 → 영원히 끝나지 않음**

---

## **✔️ Deadlock이 왜 발생할까?**

- 트랜잭션 실행 순서가 서로 뒤엉킴

- 너무 많은 데이터를 한 번에 수정

- 격리 수준이 높을 때

---

## **✔️ Deadlock 해결 방법 (실무 기준)**

### **1) 작업 순서를 일관되게 유지**

```
항상 user → order → product 순서로 update한다
```

### **2) 트랜잭션을 짧게 유지**

- 오래 잡고 있으면 다른 트랜잭션이 기다리게 됨

### **3) 불필요한 Lock 피하기**

- SELECT에도 의도치 않은 LOCK이 걸릴 수 있음

- MySQL: SELECT ... FOR UPDATE 주의

### **4) 재시도 로직 수행**

DB는 Deadlock을 감지하면 한 쪽을 강제로 종료시킴

→ 앱단에서는 다시 한 번 실행하면 해결됨

### **5) 격리 수준 조정**

- 너무 높은 격리수준은 Deadlock 가능성을 높임

    
    (Read Committed로 낮추는 방향 고려)

    

# **✅ 최종 정리**

| **항목** | **핵심 내용** |
| --- | --- |
| **트랜잭션/ACID** | 트랜잭션은 작업의 묶음이며 ACID로 데이터의 안전성을 보장 |
| **COMMIT/ROLLBACK** | 작업 확정 / 취소 |
| **Isolation Level** | 트랜잭션 간 간섭을 얼마나 허용할지 결정 (성능 ↔ 안정성 Trade-off) |
| **Deadlock** | 서로 기다리며 멈추는 상황 → 순서 통일, 트랜잭션 짧게, 재시도 로직으로 해결 |

